# チャットアプリケーション 実装状況

## 1. 実装済みのコンポーネント

### 1.1 データモデル
```csharp
public class ChatThread
{
    public string Id { get; set; }
    public string Title { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime LastMessageAt { get; set; }
    public string Provider { get; set; }  // デフォルトClaude
    public string? SystemPrompt { get; set; }  // null許容
    public bool IsSystemPromptEnabled { get; set; }
}

public class Message
{
    public string Id { get; set; }
    public string ThreadId { get; set; }
    public string Role { get; set; }
    public DateTime Timestamp { get; set; }
    public virtual ICollection<MessageElement> MessageElements { get; set; }
}

public class MessageElement
{
    public string Id { get; set; }
    public string MessageId { get; set; }
    public string Type { get; set; }  // Text/Code/Image/Expression
    public string Content { get; set; }
    public string? Language { get; set; }  // コードブロック用、null許容
    public DateTime Timestamp { get; set; }
    public virtual Message Message { get; set; }
}

public class MigrationHistory
{
    public int Id { get; set; }
    public int Version { get; set; }
    public string Name { get; set; }
    public DateTime AppliedAt { get; set; }
    public string Description { get; set; }
    public bool IsSuccess { get; set; }
    public string? ErrorMessage { get; set; }
}
```

### 1.2 データアクセス
```csharp
public class ChatDbContext : DbContext
{
    public DbSet<ChatThread> Threads { get; set; }
    public DbSet<Message> Messages { get; set; }
    public DbSet<MessageElement> MessageElements { get; set; }
    public DbSet<MigrationHistory> MigrationHistory { get; set; }
}

public interface IChatDataManager
{
    Task<string> CreateThreadAsync(string title, string provider = "Claude", string? systemPrompt = null, bool isSystemPromptEnabled = false);
    Task<ChatThread?> GetThreadAsync(string threadId);
    Task<List<ChatThread>> GetAllThreadsAsync();
    Task<string> AddMessageAsync(string threadId, string role, string content);
    Task<List<Message>> GetMessagesAsync(string threadId);
}
```

### 1.3 サービス
```csharp
public interface ILLMApiService  // 旧IClaudeService
{
    Task<string> GetResponseAsync(string message);
    Task InitializeAsync(string apiKey);
    Task<bool> LoadApiKey();
    Task ClearApiKey();
    void ClearHistory();
    bool IsInitialized { get; }
    IReadOnlyList<ChatMessage> ConversationHistory { get; }
}

public class ChatService
{
    // スレッド履歴管理
    private readonly Dictionary<string, List<Message>> _threadMessages = new();
    private ILLMApiService _currentService;

    public async Task LoadThread(string threadId);
    public async Task<string> SendMessage(string threadId, string message);
    public List<Message> GetThreadMessages(string threadId);
}
```

## 2. これから実装するUI構成

### Phase 1: 基本UI
1. メイン画面（Slack風）
   - 左ペイン：スレッド一覧
   - 新規作成フィールド
   - 開発者メニューボタン
   - 右ペイン：チャット表示

2. スレッド作成/設定画面
   - タイトル
   - プロバイダー選択
   - システムプロンプト設定
   - 有効/無効切り替え

3. 開発者画面
   - APIキー設定
   - デフォルトシステムプロンプト管理

### Phase 2: API通信
1. APIキー管理?
2. メッセージ送受信?
3. 履歴管理
4. システムプロンプト制御
5. マルチプロバイダー対応★

### Phase 3: 拡張機能
1. コードスニペット対応
2. 画像添付機能
3. その他機能拡張

## 3. 保留中の機能
- 画像対応詳細設計
- モデル選択機能
- スレッドタイトル変更
- スレッド削除


## 4. 必要なNuGetパッケージ
```xml
<PackageReference Include="Microsoft.EntityFrameworkCore.Sqlite" Version="7.0.0" />
<PackageReference Include="Microsoft.Toolkit.Mvvm" Version="8.0.0" />
<PackageReference Include="CommunityToolkit.Maui" Version="5.0.0" />
<PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="7.0.0">
<PackageReference Include="SQLitePCLRaw.bundle_green" Version="2.1.0" />
```

## 5. 注意点
- APIキーは開発者向け機能として実装
- システムプロンプトはスレッドごとにカスタマイズ可能
- マイグレーション機能は初期から実装
- UI実装を優先し、段階的に機能追加


変更前
public interface ILLMApiService
{
    Task<string> GetResponseAsync(string message);
    // これらは不要になる
    void ClearHistory();
    IReadOnlyList<ChatMessage> ConversationHistory { get; }
}

変更後
public interface ILLMApiService
{
    Task<string> GetResponseAsync(
        string message, 
        List<Message> conversationHistory,  // 履歴はChatServiceが管理
        string? systemPrompt = null         // スレッドから取得
    );
    Task InitializeAsync(string apiKey);
    Task<bool> LoadApiKey();
    Task ClearApiKey();
    bool IsInitialized { get; }
}


■画面案
1．スレッド一覧画面
[＋新規作成]  ← ボタンではなく入力フィールド＋追加ボタン
スレッド一覧
├─ スレッド1
├─ スレッド2
└─ スレッド3

2. スレッド作成/設定画面
タイトル: [スレッド1]
プロバイダー: [Claude ▼]
システムプロンプト:
┌────────┐
│デフォルト  ▼│ 
└────────┘
[x] 有効にする

[作成] [キャンセル]

3. チャット画面
スレッド1
─────────
チャット内容
...

＝＝＝↓見せた＝＝＝

■コードスぺニット
[通常のテキスト]
┌─[言語名]───[コピー]─┐
│ code                │
│ code                │
└──────────────────┘
[通常のテキスト]



■
はい、すみません。```の単純な含有チェックではダメですね。
では、メッセージをパースして複数のUIエレメントとして扱うアプローチに変更します：

メッセージの構造体


public class MessageElement
{
    public MessageElementType Type { get; set; }  // Text or CodeBlock
    public string Content { get; set; }
    public string Language { get; set; }  // CodeBlockの場合のみ使用
}

public enum MessageElementType
{
    Text,
    CodeBlock
}

メッセージのパース

public class MessageParser
{
    // コードブロックのパターン: ```language\ncode\n```
    private static readonly Regex CodeBlockRegex = 
        new Regex(@"```(\w+)?\n(.*?)```", RegexOptions.Singleline);

    public List<MessageElement> Parse(string message)
    {
        var elements = new List<MessageElement>();
        var lastIndex = 0;

        foreach (Match match in CodeBlockRegex.Matches(message))
        {
            // マッチの前のテキストを追加
            if (match.Index > lastIndex)
            {
                elements.Add(new MessageElement
                {
                    Type = MessageElementType.Text,
                    Content = message[lastIndex..match.Index]
                });
            }

            // コードブロックを追加
            elements.Add(new MessageElement
            {
                Type = MessageElementType.CodeBlock,
                Language = match.Groups[1].Value,
                Content = match.Groups[2].Value.Trim()
            });

            lastIndex = match.Index + match.Length;
        }

        // 残りのテキストを追加
        if (lastIndex < message.Length)
        {
            elements.Add(new MessageElement
            {
                Type = MessageElementType.Text,
                Content = message[lastIndex..]
            });
        }

        return elements;
    }
}

ViewModelの拡張
public class ChatMessage
{
    public string Role { get; set; }
    public string RawContent { get; set; }
    public List<MessageElement> Elements { get; set; }
}

表示
<CollectionView ItemsSource="{Binding Elements}">
    <CollectionView.ItemTemplate>
        <DataTemplate>
            <!-- 通常テキストとコードブロックで分岐 -->
            <Grid>
                <!-- テキスト用View -->
                <Label IsVisible="{Binding Type, Converter={StaticResource IsTextTypeConverter}}"
                       Text="{Binding Content}" />
                
                <!-- コードブロック用View -->
                <local:CodeBlockView 
                    IsVisible="{Binding Type, Converter={StaticResource IsCodeBlockTypeConverter}}"
                    Code="{Binding Content}"
                    Language="{Binding Language}" />
            </Grid>
        </DataTemplate>
    </CollectionView.ItemTemplate>
</CollectionView>

このアプローチのメリット：

正確なパース処理
言語指定の適切な処理
コードブロックとテキストの明確な分離

デメリット：

若干複雑な実装
メモリ使用量の増加

この方向性でいかがでしょうか？

colkectionviewって、よくわかってないんだけどitemscontrolみたいなもん？、んで中でデータタイプで自表示分けするみたいな？

はい、その認識で合っています。
CollectionViewはMAUIでの基本的なコレクション表示コントロールで、ItemsControlの進化版みたいなものです。
基本的な機能：

ItemsSourceにコレクションをバインド
ItemTemplateで表示方法を指定
ItemTemplateSelectorで表示を分岐

簡単な例：


<CollectionView ItemsSource="{Binding Messages}">
    <!-- 単純な場合 -->
    <CollectionView.ItemTemplate>
        <DataTemplate>
            <Label Text="{Binding Content}" />
        </DataTemplate>
    </CollectionView.ItemTemplate>

    <!-- 分岐が必要な場合 -->
    <CollectionView.ItemTemplateSelector>
        <local:MessageTemplateSelector>
            <local:MessageTemplateSelector.TextTemplate>
                <DataTemplate>
                    <controls:TextMessageControl />
                </DataTemplate>
            </local:MessageTemplateSelector.TextTemplate>
            <local:MessageTemplateSelector.ImageTemplate>
                <DataTemplate>
                    <controls:ImageMessageControl />
                </DataTemplate>
            </local:MessageTemplateSelector.ImageTemplate>
        </local:MessageTemplateSelector>
    </CollectionView.ItemTemplateSelector>
</CollectionView>

特徴：

仮想化（表示範囲のみレンダリング）
レイアウトのカスタマイズ（垂直、水平、グリッド等）
パフォーマンスの最適化
選択機能

WPFのItemsControlと同様の考え方で使えます。


きっとitemssourceでデータを、抽象化して持ってるんだよね？


そうですね！
MessageElement（抽象）を使って、具体的なデータ型を隠蔽する形になります：

// 基底クラス（抽象）
public abstract class MessageElement
{
    public DateTime Timestamp { get; set; }
    // 共通プロパティ
}

// 具体的な実装
public class TextMessageElement : MessageElement
{
    public string Content { get; set; }
}

public class ImageMessageElement : MessageElement
{
    public ImageSource Source { get; set; }
}

public class CodeBlockElement : MessageElement
{
    public string Code { get; set; }
    public string Language { get; set; }
}

// ViewModel
public ObservableCollection<MessageElement> Messages { get; } = new();

こうすることで：

型安全
各要素に固有のプロパティを持てる
TemplateSelector側で型に応じた分岐が容易

という利点がありますね。この方向で良さそうでしょうか？

うん。いいと思う。これまでの機能を考慮してデータを映像化したい。slackみたいなuiでスレッドごとに会話履歴を持つの。

なるほど、データの可視化をしてみましょう。
スレッドデータの構造をMermaidで表現してみます：

classDiagram
    Thread "1" *-- "many" ChatMessage
    ChatMessage "1" *-- "many" MessageElement
    MessageElement <|-- TextMessageElement
    MessageElement <|-- ImageMessageElement
    MessageElement <|-- CodeBlockElement

    class Thread {
        +string Id
        +string Title
        +DateTime CreatedAt
        +DateTime LastMessageAt
        +LLMProvider Provider
        +string SystemPrompt
        +List~ChatMessage~ Messages
    }

    class ChatMessage {
        +string Id
        +string Role
        +DateTime Timestamp
        +List~MessageElement~ Elements
    }

    class MessageElement {
        +DateTime Timestamp
        +abstract render()
    }

    class TextMessageElement {
        +string Content
    }

    class ImageMessageElement {
        +ImageSource Source
        +string Caption
    }

    class CodeBlockElement {
        +string Code
        +string Language
    }
    
この構造に基づいて：

データの流れ

Thread (スレッド)
  ↓
ChatMessage (ユーザー/AIの発言単位)
  ↓
MessageElement (テキスト/画像/コードの各要素)


保存について


スレッド: スレッド情報とメタデータ
メッセージ: 会話履歴
要素: 実際のコンテンツ（画像は別途ストレージ可能性）

この構造でよさそうでしょうか？

いいと思う。スレッドを開いたら該当するidから、会話を引っ張ってくる形かな？

そうですね。スレッド一覧→会話履歴の流れは以下のようになります：

データの読み込みフロー

// ChatViewModelの例
public class ChatViewModel
{
    private readonly IThreadRepository _repository;
    public ObservableCollection<MessageElement> Messages { get; }

    public async Task InitializeThread(string threadId)
    {
        // スレッドの読み込み
        var thread = await _repository.GetThreadAsync(threadId);
        // メッセージの読み込み
        var messages = await _repository.GetMessagesForThreadAsync(threadId);
        // UIの更新
        Messages.Clear();
        foreach (var message in messages.SelectMany(m => m.Elements))
        {
            Messages.Add(message);
        }
    }
}

この形で進めていきましょうか？

わかった。言い忘れてたけどシステムプロンプトはスレッドごとに有効無効を管理したい

はい、Thread クラスを拡張して、システムプロンプトの有効/無効状態を管理しましょう。

はい、Thread クラスを拡張して、システムプロンプトの有効/無効状態を管理しましょう。

# チャットアプリケーション 詳細設計書

## 1. データ構造

### 1.1 Thread（スレッド）
```csharp
public class Thread
{
    public string Id { get; set; }
    public string Title { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime LastMessageAt { get; set; }
    public LLMProvider Provider { get; set; }
    public string SystemPrompt { get; set; }
    public bool IsSystemPromptEnabled { get; set; }
    public List<ChatMessage> Messages { get; set; }
}
```

そして使用フロー：

スレッド作成時

新規スレッド作成
  ↓
デフォルトのシステムプロンプトを設定
  ↓
IsSystemPromptEnabled = true （デフォルト値）

チャット時

メッセージ送信
  ↓
スレッドのIsSystemPromptEnabledをチェック
  ↓
有効な場合のみシステムプロンプトを含めてAPIに送信

この形でよろしいでしょうか？

いいです。後学のために詳細設計書を書いてください。

＝＝＝↑見せた＝＝＝

### 1.2 メッセージ要素
```csharp
public abstract class MessageElement
{
    public DateTime Timestamp { get; set; }
    public abstract void Render();
}

public class TextMessageElement : MessageElement
{
    public string Content { get; set; }
}

public class ImageMessageElement : MessageElement
{
    public ImageSource Source { get; set; }
    public string Caption { get; set; }
}

public class CodeBlockElement : MessageElement
{
    public string Code { get; set; }
    public string Language { get; set; }
}
```

## 2. ViewModelの構造

### 2.1 ThreadListViewModel
```csharp
public class ThreadListViewModel : ObservableObject
{
    private readonly IThreadRepository _repository;
    public ObservableCollection<ThreadListItem> Threads { get; }
    
    // スレッド選択時のナビゲーション
    public async Task SelectThread(string threadId)
    {
        await NavigationService.NavigateAsync<ChatViewModel>(
            new Dictionary<string, object> { { "threadId", threadId } }
        );
    }
}
```

### 2.2 ChatViewModel
```csharp
public class ChatViewModel : ObservableObject
{
    private readonly IThreadRepository _repository;
    private readonly IClaudeService _claudeService;
    
    public ObservableCollection<MessageElement> Messages { get; }
    
    public async Task InitializeThread(string threadId)
    {
        var thread = await _repository.GetThreadAsync(threadId);
        await LoadMessages(thread);
    }
    
    public async Task SendMessage(string content)
    {
        // システムプロンプトの制御を含むメッセージ送信
    }
}
```

## 3. UIコンポーネント

### 3.1 メッセージ表示用カスタムコントロール
```xaml
<!-- TextMessageControl -->
<ContentView x:Class="YourApp.Controls.TextMessageControl">
    <Label Text="{Binding Content}" />
</ContentView>

<!-- ImageMessageControl -->
<ContentView x:Class="YourApp.Controls.ImageMessageControl">
    <Image Source="{Binding Source}"
           Aspect="AspectFit"
           HeightRequest="200" />
</ContentView>

<!-- CodeBlockControl -->
<ContentView x:Class="YourApp.Controls.CodeBlockControl">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>
        
        <!-- ヘッダー（言語表示とコピーボタン） -->
        <Grid Grid.Row="0">
            <Label Text="{Binding Language}" />
            <Button Command="{Binding CopyCommand}"
                    Text="Copy" 
                    HorizontalOptions="End"/>
        </Grid>
        
        <!-- コード表示 -->
        <Editor Grid.Row="1"
                Text="{Binding Code}"
                IsReadOnly="True"/>
    </Grid>
</ContentView>
```

### 3.2 メインチャット画面
```xaml
<ContentPage>
    <Grid>
        <!-- メッセージ表示領域 -->
        <CollectionView ItemsSource="{Binding Messages}">
            <CollectionView.ItemTemplateSelector>
                <local:MessageTemplateSelector
                    TextTemplate="{StaticResource TextMessageTemplate}"
                    ImageTemplate="{StaticResource ImageMessageTemplate}"
                    CodeBlockTemplate="{StaticResource CodeBlockTemplate}" />
            </CollectionView.ItemTemplateSelector>
        </CollectionView>
        
        <!-- 入力領域 -->
        <Grid Grid.Row="1">
            <Entry Text="{Binding InputText}" />
            <Button Command="{Binding SendCommand}"
                    Text="Send" />
        </Grid>
    </Grid>
</ContentPage>
```

## 4. データフロー

### 4.1 スレッド一覧表示
1. アプリ起動
2. ThreadListViewModelの初期化
3. IThreadRepositoryからスレッド一覧を取得
4. ObservableCollection<ThreadListItem>にバインド

### 4.2 スレッド選択時
1. ThreadListViewModelでスレッド選択イベント発生
2. NavigationServiceを使用してChatViewModelに遷移
3. ChatViewModelの初期化（threadIdパラメータ使用）
4. 該当スレッドのメッセージを読み込み
5. メッセージをCollectionViewにバインド

### 4.3 メッセージ送信時
1. SendCommandの実行
2. システムプロンプトの有効/無効確認
3. ClaudeAPIの呼び出し
4. レスポンスのパース
5. MessageElementsへの変換
6. CollectionViewの更新

## 5. 主要な機能実装

### 5.1 コードブロック検出
```csharp
public class MessageParser
{
    private static readonly Regex CodeBlockRegex = 
        new Regex(@"```(\w+)?\n(.*?)```", RegexOptions.Singleline);
        
    public List<MessageElement> Parse(string content)
    {
        var elements = new List<MessageElement>();
        // パース処理
        return elements;
    }
}
```

### 5.2 画像添付
```csharp
public async Task AttachImage()
{
    var result = await MediaPicker.PickPhotoAsync();
    if (result != null)
    {
        var element = new ImageMessageElement
        {
            Source = ImageSource.FromFile(result.FullPath),
            Timestamp = DateTime.UtcNow
        };
        Messages.Add(element);
    }
}
```

### 5.3 システムプロンプト制御
```csharp
public async Task ToggleSystemPrompt()
{
    var thread = await _repository.GetThreadAsync(_currentThreadId);
    thread.IsSystemPromptEnabled = !thread.IsSystemPromptEnabled;
    await _repository.UpdateThreadAsync(thread);
}
```

## 6. エラーハンドリング

### 6.1 主要なエラーケース
- API通信エラー
- 画像ファイルの読み込みエラー
- データベース操作エラー

### 6.2 エラーハンドリング方針
```csharp
public async Task<Result<T>> TryOperationAsync<T>(Func<Task<T>> operation)
{
    try
    {
        var result = await operation();
        return Result<T>.Success(result);
    }
    catch (ApiException ex)
    {
        // API特有のエラーハンドリング
        return Result<T>.Failure(ex.Message);
    }
    catch (Exception ex)
    {
        // 一般的なエラーハンドリング
        return Result<T>.Failure("予期せぬエラーが発生しました");
    }
}
```

## 7. パフォーマンス最適化

### 7.1 メッセージ表示の最適化
- CollectionViewの仮想化機能の活用
- 画像のキャッシュ管理
- メッセージの遅延読み込み

### 7.2 データベースアクセスの最適化
- インデックス設計
- クエリの最適化
- キャッシュの活用

## 8. セキュリティ考慮事項

### 8.1 APIキーの保護
- Secure Storageの使用
- キーの暗号化

### 8.2 データの保護
- ローカルデータの暗号化
- センシティブ情報の適切な処理

## 9. テスト計画

### 9.1 単体テスト対象
- MessageParser
- ViewModelのロジック
- データ変換処理

### 9.2 結合テスト対象
- スレッド管理機能
- メッセージング機能
- 画像添付機能

### 9.3 UIテスト対象
- メッセージ表示
- ナビゲーション
- エラー表示

## 10. 展開計画

### 10.1 必要な環境変数
- API_ENDPOINT
- DEFAULT_SYSTEM_PROMPT
- MAX_IMAGE_SIZE

### 10.2 依存関係
- .NET MAUI
- SQLite
- CloudinaryまたはAzure Blob Storage（画像保存用）